require 'Util'

local fieldmt = {}
fieldmt._type = "Field"
fieldmt.__index = fieldmt
local momentummap = { GL="GL", SL="TGL", U="AH", SU="TAH" }

function Field(lattice, opts)
  local f = {}
  f.lattice = lattice
  f.precision = lattice.defaultPrecision
  f.nupdate = 0
  f.wantForce = true
  --f.parents = nil -- hash of [parent]=nupdate
  --f.filename = nil
  --f.metadata = nil
  if opts.kind == "gauge" then
    f.group = lattice.defaultGroup
    f.nc = lattice.defaultNc
  end
  tableCopyTo(f, opts)
  if f.kind == "gauge" then
    if f.momentum then
      f.field = qopqdp.force(f.precision, f.nc, lattice.qdplat)
      f.name = "M" .. f.group .. f.nc
    else
      f.field = qopqdp.gauge(f.precision, f.nc, lattice.qdplat)
      f.name = "GF" .. f.group .. f.nc
    end
  else
    --f.name = "F" .. opts.kind
    error(string.format("unknown Field kind: %s\n", f.kind))
  end
  clearStats(f, "update")
  return setmetatable(f,fieldmt)
end

function fieldmt.__tostring(self)
  local s = {}
  tostringRecurse(s, self, {self.lattice})
  if s.done then return "" end
  s[#s+1] = self.name
  s[#s+1] = " = "
  s[#s+1] = self.lattice.name
  s[#s+1] = ":Field {\n"
  s[#s+1] = string.format("  group = \"%s\",\n",self.group)
  s[#s+1] = string.format("  nc = %g\n",self.nc)
  s[#s+1] = "}\n"
  return table.concat(s)
end

-- group, momentum group
function fieldmt.Momentum(self)
  local fgroup = momentummap[self.group]
  return Field(self.lattice, {kind=self.kind,group=fgroup,nc=self.nc,
			      precision=self.precision,momentum=true})
end

function fieldmt.CopyField(self)
  local f = self.field:copy()
  return f
end

function fieldmt.SetField(self, f)
  self.field:set(f)
end

function fieldmt.Clone(self)
  local f = tableCopy(self)
  f.field = qopqdp.gauge(f.precision, f.nc, f.lattice.qdplat)
  f.field:set(self.field)
  return setmetatable(f,fieldmt)
end

function fieldmt.Set(self, opts, ...)
  if type(opts)=="table" then
    local t = opts._type
    if t=="Field" then
      self.field:set(opts.field)
      self.nupdate = self.nupdate + 1
    elseif t==nil then
      tableCopyTo(self, opts)
    else
      error("unknown type for opts: %s\n", t)
    end
  elseif type(opts)=="string" then
    self.field[opts](self.field, ...)
    self.nupdate = self.nupdate + 1
  else
    error("unknown type for opts: %s\n", type(opts))
  end
end

function fieldmt.Load(self, filename)
  local fmd,rmd = self.field:load(filename)
  self.filename = filename
  self.metadata = {file=fmd,record=rmd}
  self.nupdate = self.nupdate + 1
end

function fieldmt.Save(self, filename, opts)
  if not self.metadata then
    self.metadata = {}
  end
  if not self.metadata.file then
    self.metadata.file =
      "<?xml version=\"1.0\"?>\n<note>generated by qhmc</note>\n"
  end
  if not self.metadata.record then
    self.metadata.record =
      "<?xml version=\"1.0\"?>\n<note>generated by qhmc</note>\n"
  end
  local precision = (opts and opts.precision) or 'F'
  self.field:save(filename,self.metadata.file,self.metadata.record,precision)
  self.filename = filename
end

function fieldmt.Norm2(self)
  return self.field:norm2()
end

function fieldmt.Random(self, var) -- ... for variance
  if self.momentum then
    if var then
      self.field:random(var) -- FIXME: only does TAH
    else
      self.field:random() -- FIXME: only does TAH
    end
  else
    self.field:random() -- FIXME: only does SU
  end
end

function fieldmt.Update(self, momentum, eps)
  local t0 = clock()
  --printf("Field:update: %s\t%g\n", tostring(momentum), eps)
  -- for gauge: exponential, for momentum: add
  self.field:update(momentum.field, eps)
  updateStats(self, "update", {seconds=(clock()-t0)})
  self.nupdate = self.nupdate + 1
end
